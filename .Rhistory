install.packages("shinydashboard")
library(shinydashboard)
?bubbles
?dplyr
??dplyr
?session
str(session)
library(shiny)
str(session)
str(sessionInfo)
head(faithful)
library(tm)
library(wordcloud)
#############The below code is needed to prepare both skills and job market analysis
#############
#### Make sure to have the 'twoThousandJobs.csv' file in your project directory. This is the source dataset that we import into the working environment using the below code
df_twoThousandJobs <- read.csv("~/R/win-library/3.3/ICT_Project_TEST/twoThousandJobs.csv", stringsAsFactors=FALSE)
# clean the date column so that it can be represented as a DATE. This will enable R to interpret it for time relevant analysis
df_twoThousandJobs$Date <- sub("categorized-","",df_twoThousandJobs$Date)
df_twoThousandJobs$Date <- as.Date(df_twoThousandJobs$Date)
# Subsetting the Jobs by there classifications e.g. Developer, Business Analyst and Consultant
df_developerJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Developer")
df_businessAnalystJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Business Analysts")
df_consultantJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Consultants")
df_architectsJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Architects")
df_administrationJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Administration")
df_databaseJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Database Development")
df_engineeringJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Engineering")
df_helpDeskJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Help Desk and Support")
df_securityJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Security")
df_managementJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Management")
df_telecomJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Telecommunications")
df_testingJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Testing and Quality")
#############Running the below code tells us what skills relate to what jobs
#Make sure to change the dataframsource that you wish to perform the skills analysis on e.g. df_developerJobs for Developer Classification
df_source <- DataframeSource(df_testingJobs)
df_corpus <- VCorpus(df_source)
clean_corpus <- function(corpus) {
corpus <- tm_map(corpus, content_transformer(tolower))
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, removeNumbers)
corpus <- tm_map(corpus, stripWhitespace)
corpus <- tm_map(corpus, removeWords, c(stopwords("en"), "job", "description", "descriptionduties",
"australia",
"australian",
"including",
"include",
"branch",
"applicants",
"will",
"with",
"within",
"must",
"ensure",
"department"))
return(corpus)}
df_corpus <- clean_corpus(df_corpus)
#A Term Document matrix can be used for multiple text mining functions
tdm_JobandSkills <- TermDocumentMatrix(df_corpus)
m_JobandSkills <- as.matrix(tdm_JobandSkills)
term_freq_JobandSkills <- rowSums(m_JobandSkills)
term_freq_JobandSkills <- sort(term_freq_JobandSkills, decreasing = TRUE)
word_freq <- data.frame(term = names(term_freq_JobandSkills), num = term_freq_JobandSkills)
#lets make a pretty wordcloud for the Developer Classification
wordcloud(word_freq$term, word_freq$num, max.words = 100, colors = "red")
#####################The below code is for generating plot that displays most commonly occuring classification
########This shows us job markets in demand
#get only IT categories by binding all of the already subsetted classifications
df_ITIJobs <- rbind(
#df_administrationJobs,
df_architectsJobs,
#df_businessAnalystJobs,
#df_consultantJobs,
df_databaseJobs,
df_developerJobs,
df_engineeringJobs,
#df_helpDeskJobs,
#df_managementJobs,
df_securityJobs,
df_telecomJobs,
df_testingJobs)
#change the appropriate characters into factors so that the "levels" can be represented
df_ITIJobs$Classification = as.factor(df_ITIJobs$Classification)
df_ITIJobs$Level = as.factor(df_ITIJobs$Level)
df_ITIJobs$JobType = as.factor(df_ITIJobs$JobType)
#plot out the most commonly occuring classifications
plot(df_ITIJobs$Classification)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
str(df_ITIJobs)
runApp()
runApp()
runApp()
runApp()
?renderTable
?renderDataTable
runApp()
?options
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
install.packages("memoise")
library(memoise)
?memoise
?sprintf
runApp()
runApp()
rm(classifications)
rm(classifcations)
rm(getTermMatrix)
rm(tdm_JobandSkills)
runApp()
rm(classifications)
runApp()
runApp()
str(getTermMatrix)
getTermMatrix()
runApp()
?wordcloud
# This is the server logic for a Shiny web application.
# You can find out more about building applications with Shiny here:
#
# http://shiny.rstudio.com
#
shinyServer(function(input, output, session) {
# The below output$classificationPlot is used for plotting the classification bar graph
output$classificationPlot <- renderPlot({
# generate bins based on input$bins from ui.R
jclass    <- df_ITIJobs$Classification
# plot out the job classifications
plot(jclass, col = 'darkgray', border = 'white')
})
# Define a reactive expression for the document term matrix
terms <- reactive({
# Change when the "update" button is pressed...
input$update
# ...but not for anything else
isolate({
withProgress({
setProgress(message = "Processing corpus...")
getTermMatrix(input$selection)
})
})
})
# Make the wordcloud drawing predictable during a session
wordcloud_rep <- repeatable(wordcloud)
# The below output$wordcloudPlot is used for plotting the skills wordcloud
output$wordcloudPlot <- renderPlot({
# The below code is needed to set the word frequency limit
x <- terms()
# Code needs to be added that edits the 'max.words' output
wordcloud_rep(names(x), x, min.freq = input$freq, max.words = input$max, colors = "red")
})
# The below output$rawDataset is used for displaying the raw data used in this analysis
output$rawDataset <- renderPrint({
rawDisplay <- df_ITIJobs[0:100,c("Classification", "Date")]
print(rawDisplay)
})
})
Terms()
terms()
books
View(df_ITIJobs)
rm(classifications)
runApp()
rm(list = ls(all.names = ""))
runApp()
rm(classifications, getTermMatrix)
runApp()
rm(list = ls(all.names = ""))
runApp()
rm(list = ls(all.names = ""))
runApp()
runApp()
runApp()
install.packages("RColorBrewer")
install.packages("RColorBrewer")
library(RColorBrewer)
?png
?wordcloud
??wordcloud
shiny::runApp()
?rngfunc
??rngfunc
runApp()
rm(list = ls(all.names = ""))
runApp()
rm(list = ls(all.names = ""))
runApp()
rm(list = ls(all.names = ""))
runApp()
rm(list = ls(all.names = ""))
??wordcloud
runApp()
runApp()
runApp()
install.packages("wordcloud")
install.packages("wordcloud")
library(wordcloud)
install.packages("wordcloud")
install.packages("wordcloud")
library(wordcloud)
rm(list = ls(all.names = ""))
shiny::runApp()
###################################################################################################################################
#### Make sure to have the 'twoThousandJobs.csv' file in your project directory. This is the source dataset that we import into the working environment using the below code
df_twoThousandJobs <- read.csv("~/R/win-library/3.3/ICT_Project_TEST/twoThousandJobs.csv", stringsAsFactors=FALSE)
# clean the date column so that it can be represented as a DATE. This will enable R to interpret it for time relevant analysis
df_twoThousandJobs$Date <- sub("categorized-","",df_twoThousandJobs$Date)
df_twoThousandJobs$Date <- as.Date(df_twoThousandJobs$Date)
# Subsetting the Jobs by there classifications e.g. Developer, Business Analyst and Consultant
df_developerJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Developer")
#df_businessAnalystJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Business Analysts")
#df_consultantJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Consultants")
df_architectsJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Architects")
#df_administrationJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Administration")
df_databaseJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Database Development")
df_engineeringJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Engineering")
#df_helpDeskJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Help Desk and Support")
df_securityJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Security")
#df_managementJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Management")
df_telecomJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Telecommunications")
df_testingJobs <- subset(df_twoThousandJobs, df_twoThousandJobs$Classification == " Testing and Quality")
#####################The below code is for generating plot that displays most commonly occuring classification
########This shows us job markets in demand
#get only IT categories by binding all of the already subsetted classifications
df_ITIJobs <- rbind(
#df_administrationJobs,
df_architectsJobs,
#df_businessAnalystJobs,
#df_consultantJobs,
df_databaseJobs,
df_developerJobs,
df_engineeringJobs,
#df_helpDeskJobs,
#df_managementJobs,
df_securityJobs,
df_telecomJobs,
df_testingJobs)
#change the appropriate characters into factors so that the "levels" can be represented
df_ITIJobs$Classification = as.factor(df_ITIJobs$Classification)
df_ITIJobs$Level = as.factor(df_ITIJobs$Level)
df_ITIJobs$JobType = as.factor(df_ITIJobs$JobType)
runApp()
runApp()
runApp()
rm(list = ls(all.names = ""))
runApp()
str(classifications)
classifications
classifications[1]
runApp()
runApp()
classifications
str(classifications)
rm(list = ls(all.names = ""))
runApp()
str(classifications)
classifications$`All IT Jobs`
?selectInput
runApp()
runApp()
?cex
??cex
runApp()
View(df_securityJobs)
runApp()
runApp()
rm(list=ls(all.names = ""))
runApp()
str(classifications)
runApp()
rm(list = ls(all.names = ""))
?hr
?sidebarPanel
runApp()
runApp()
shiny::runApp()
selectInput(?)
?selectInput
runApp()
rm(list = ls(all.names = ""))
runApp()
str(classifications)
ls_ITIJobs <- c(df_ITIJobs, df_architectsJobs)
str(ls_ITIJobs)
ls_ITIJobs[df_ITIJobs$Description]
runApp()
?data
ls_ITIJobs["df_ITIJobs"]
ls_ITIJobs["df_ITIJobs"]
ls_ITIJobs[["df_ITIJobs"]]
ls_ITIJobs[['df_architectsJobs']]
ls_ITIJobs[[2]]
ls_ITIJobs[2]
ls_ITIJobs
str(ls_ITIJobs)
ls_ITIJobs <- list(df_ITIJobs, df_architectsJobs)
ls_ITIJobs[["df_ITIJobs"]]
ls_ITIJobs[[df_ITIJobs]]
str(ls_ITIJobs)
names(ls_ITIJobs) <- c("df_ITIJobs", "df_architectsJobs")
str(ls_ITIJobs)
ls_ITIJobs[[df_ITIJobs]]
ls_ITIJobs[["df_ITIJobs"]]
ls_ITIJobs[["df_ITIJobs"]][2]
runApp()
rm(list = ls(all.names = ""))
runApp()
rm(list = ls(all.names = ""))
runApp()
str(ls_ITIJobs)
runApp()
runApp()
runApp()
rm(list = ls(all.names = ""))
runApp()
classifications
rm(list=ls(all.names = ""))
runApp()
rm(list = ls(all.names = ""))
runApp()
runApp()
rm(list = ls(all.names = ""))
runApp()
runApp()
rm(list = ls(all.names = ""))
runApp()
rm(list = ls(all.names = ""))
runApp()
runApp()
rm(list = ls(all.names = ""))
runApp()
runApp()
runApp()
str(ls_ITIJobs)
runApp()
rm(list = ls(all.names = ""))
runApp()
rm(list = ls(all.names = ""))
shiny::runApp()
runApp()
runApp()
runApp()
rm(list = ls(all.names = ""))
closeAllConnections()
shiny::runApp()
runApp()
rm(list = ls)
rm(list = ls())
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
